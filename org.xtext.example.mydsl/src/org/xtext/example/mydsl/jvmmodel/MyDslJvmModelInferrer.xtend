/*
 * generated by Xtext 2.10.0
 */
package org.xtext.example.mydsl.jvmmodel

import com.google.inject.Inject
import org.eclipse.xtext.common.types.JvmOperation
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.xbase.XExpression
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder
import org.xtext.example.mydsl.myDsl.Action
import org.xtext.example.mydsl.myDsl.PrepareDeclaraion
import org.xtext.example.mydsl.myDsl.SuiteDeclaration
import org.xtext.example.mydsl.myDsl.TestDefinition
import org.eclipse.xtext.xbase.compiler.XbaseCompiler
import org.eclipse.xtext.common.types.JvmMember
import org.eclipse.xtext.common.types.JvmVisibility

/**
 * <p>Infers a JVM model from the source model.</p> 
 * 
 * <p>The JVM model should contain all elements that would appear in the Java code 
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>     
 */
class MyDslJvmModelInferrer extends AbstractModelInferrer {

	/**
	 * convenience API to build and initialize JVM types and their members.
	 */
	@Inject extension JvmTypesBuilder

	@Inject extension IQualifiedNameProvider

	def dispatch void infer(SuiteDeclaration suite, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {

		acceptor.accept(suite.toClass(suite.fullyQualifiedName)) [
			abstract = false
			packageName = suite.eContainer.fullyQualifiedName.toString

			members += suite.toMethod("beforeSuite", void.typeRef) [
				static = true
				annotations += annotationRef("org.junit.BeforeClass");
				val actions = suite.beforeActions
//				for (Action action : actions) {
//				}
				body = '''
				'''
			]

			members += suite.toMethod("beforeTest", void.typeRef) [
				annotations += annotationRef("org.junit.Before");
				body = ''''''
			]

			for (TestDefinition test : suite.prepare.testCases) {
				members += this.createTestMethod(test);
			}

			members += suite.toMethod("afterTest", void.typeRef) [
				annotations += annotationRef("org.junit.After");
				body = ''''''
			]

			members += suite.toMethod("afterSuite", typeRef(void)) [
				static = true
				annotations += annotationRef("org.junit.AfterClass");
				body = '''
«««					«FOR a : suite.afterActions»
«««						new «a.type.fullyQualifiedName » ;
«««					«ENDFOR»
				'''
			]
		]
	}

	def JvmOperation createTestMethod(TestDefinition test) {
		test.toMethod(test.name, typeRef(void)) [
			annotations += annotationRef("org.junit.Test");
			body = ''' 
			«FOR ex : test.block.expressions»
				Line:	«ex»
			«ENDFOR»
			ACTION BLOCK
«««			«test.block»
			«««				«FOR action : test.block»
«««				(new «action.type » (
«««					«FOR target : action.config.targets »
«««						«target» MyString
«««					«ENDFOR»
«««				)).exec(); 
«««					«ENDFOR»
			'''
		]
	}

	def dispatch void infer(TestDefinition testCase, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {
		testCase.toMethod(testCase.name + "Test", typeRef(void)) [
			annotations += annotationRef("org.junit.Test");
		]
	}
//
//	def XExpression translate(Action action) {
//	}
}
